"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayNow = void 0;
const axios_1 = __importDefault(require("axios"));
const endpoints_1 = require("./endpoints");
const uuid_1 = require("uuid");
const hash_1 = require("../utils/hash");
const errors_1 = require("../errors");
/**
 * Creates a paynow instance
 *
 * @export
 * @class PayNow
 */
class PayNow {
    /**
     * Creates an instance of PayNow.
     * @param {string} apiKey - API Key from panel
     * @param {string} signatureKey - Signature Key from panel
     * @param {PayNowOptions} [options={ sandbox: false }] - options
     * @memberof PayNow
     */
    constructor(apiKey, signatureKey, options = { sandbox: false }) {
        this.apiKey = apiKey;
        this.signatureKey = signatureKey;
        this.options = options;
        this.baseUrl = !this.options.sandbox ? endpoints_1.ProductionUrl : endpoints_1.SandboxUrl;
        this.client = axios_1.default.create({
            baseURL: this.baseUrl,
            headers: {
                'Api-Key': this.apiKey,
            },
        });
    }
    /**
     * Create a payment
     *
     * @param {Payment} payment - payment details
     * @returns {Promise<PaymentCreatedResponse>}
     * @throws {PayNowError}
     * @memberof PayNow
     */
    createPayment(payment) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const paymentRequest = hash_1.jsonStringify(payment);
                const signature = this.calculateSignature(payment);
                const { data } = yield this.client.post(endpoints_1.EndpointPayments, paymentRequest, {
                    headers: {
                        'Content-Type': 'application/json',
                        Signature: signature,
                        'Idempotency-Key': uuid_1.v4(),
                    },
                });
                return data;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.PayNowError(resp.statusCode, resp.errors);
                }
                throw new errors_1.PayNowError(error.response.status);
            }
        });
    }
    /**
     * Retrieves payment status after the payment request has been submitted
     *
     * @param {string} paymentId - Unique ID of a payment generated by Paynow
     * @returns {Promise<PaymentStatusResponse>}
     * @throws {PayNowError}
     * @memberof PayNow
     */
    paymentStatus(paymentId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.client.get(`${endpoints_1.EndpointPayments}/${paymentId}/status`);
                return data;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.PayNowError(resp.statusCode, resp.errors);
                }
                throw new errors_1.PayNowError(error.response.status);
            }
        });
    }
    /**
     * Create refund request
     *
     * @param {string} paymentId - payment id from paynow
     * @param {number} amount - amount to refund
     * @param {RefundReason} reason - reason for refund
     * @returns {Promise<RefundCreatedResponse>}
     * @memberof PayNow
     */
    createRefundRequest(paymentId, amount, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const refundRequest = hash_1.jsonStringify({
                    amount: amount,
                    reason: reason,
                });
                const signature = this.calculateSignature(refundRequest);
                const { data } = yield this.client.post(`${endpoints_1.EndpointPayments}/${paymentId}/refunds`, refundRequest, {
                    headers: {
                        'Content-Type': 'application/json',
                        Signature: signature,
                        'Idempotency-Key': uuid_1.v4(),
                    },
                });
                return data;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.PayNowError(resp.statusCode, resp.errors);
                }
                throw new errors_1.PayNowError(error.response.status);
            }
        });
    }
    /**
     * Check refund status of an refund request
     *
     * @param {string} refundId - id for refund
     * @returns {Promise<RefundStatusResponse>}
     * @memberof PayNow
     */
    refundStatus(refundId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data } = yield this.client.get(`${endpoints_1.EndpointRefunds}/${refundId}/status`);
                return data;
            }
            catch (error) {
                if (error.response && error.response.data) {
                    const resp = error.response.data;
                    throw new errors_1.PayNowError(resp.statusCode, resp.errors);
                }
                throw new errors_1.PayNowError(error.response.status);
            }
        });
    }
    /**
     * Calculate signature
     *
     * @param {string|object} data - data for calculate signature
     * @returns {string}
     * @memberof PayNow
     */
    calculateSignature(data) {
        let hmacData;
        if (typeof data === 'string') {
            hmacData = data;
        }
        else {
            hmacData = hash_1.jsonStringify(data);
        }
        return hash_1.calculateHmac(this.signatureKey, hmacData);
    }
}
exports.PayNow = PayNow;
//# sourceMappingURL=PayNow.js.map