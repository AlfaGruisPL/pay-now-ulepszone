import Axios, { AxiosInstance } from 'axios';
import { PayNowOptions } from './PayNowOptions';
import { EndpointPayments, ProductionUrl, SandboxUrl } from './endpoints';
import { Payment } from '../payment';
import { v4 as uuidv4 } from 'uuid';
import { calculateHmac, jsonStringify } from '../utils/hash';
import { ErrorResponse, PaymentCreatedResponse, PaymentStatusResponse } from '../responses';
import { PayNowError } from '../errors';


export class PayNow {
    private apiKey: string
    private signatureKey: string
    private baseUrl: string
    private client: AxiosInstance
    private options: PayNowOptions

    constructor(
        apiKey: string,
        signatureKey: string,
        options: PayNowOptions = { sandbox: false }
    ) {
        this.apiKey = apiKey
        this.signatureKey = signatureKey
        this.options = options
        this.baseUrl = !this.options.sandbox ? ProductionUrl : SandboxUrl;

        this.client = Axios.create({
            baseURL: this.baseUrl,
            headers: {
                'Api-Key': this.apiKey
            }
        })
    }

    /**
     * Create a payment
     *
     * @param {Payment} payment - payment details
     * @returns {Promise<PaymentCreatedResponse>}
     * @throws {PayNowError}
     * @memberof PayNow
     */
    public async createPayment (payment: Payment): Promise<PaymentCreatedResponse> {
        try {
            const paymentRequest = jsonStringify(payment)
            const signature = this.calculateSignature(paymentRequest)

            const { data } = await this.client.post(EndpointPayments, paymentRequest, {
                headers: {
                    'Content-Type': 'application/json',
                    'Signature': signature,
                    'Idempotency-Key': uuidv4()
                }
            })

            return <PaymentCreatedResponse>data
        } catch (error) {
            if (error.response && error.response.data) {
                const resp = <ErrorResponse>error.response.data
                throw new PayNowError(resp.statusCode, resp.errors)
            }
            throw new PayNowError(error.response.status)
        }
    }

    /**
     * Retrieves payment status after the payment request has been submitted
     *
     * @param {string} paymentId - Unique ID of a payment generated by Paynow
     * @returns {Promise<PaymentStatusResponse>}
     * @throws {PayNowError}
     * @memberof PayNow
     */
    public async paymentStatus (paymentId: string): Promise<PaymentStatusResponse> {
        try {
            const { data } = await this.client.get(`${EndpointPayments}/${paymentId}/status`)
            return <PaymentStatusResponse>data
        } catch (error) {
            if (error.response && error.response.data) {
                const resp = <ErrorResponse>error.response.data
                throw new PayNowError(resp.statusCode, resp.errors)
            }
            throw new PayNowError(error.response.status)
        }
    }

    /**
     * Calculate signature
     *
     * @param {string} requestData - request data as a string
     * @returns {string}
     * @memberof PayNow
     */
    public calculateSignature (requestData: string): string {
        return calculateHmac(this.signatureKey, requestData)
    }
}
